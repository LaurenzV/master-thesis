= Comparison

In this section, we will contrast the architecture of three different CPU-based 2D renderers against Vello CPU to highlight the similarities but also the differences. Since there is little literature describing the inner workings of those, we will base most of our descriptions on a best-effort analysis of the source code.

The comparison will demonstrate that certain parts of the 2D rendering pipeline are, with the exception of a few implementation details, virtually universal across different implementations. Yet, the core path-rendering algorithm of Vello CPU, underpinned by the sparse strips paradigm, is a very distinguishing feature that has not been implemented before.

== Raqote
The first renderer is raqote, a relatively simple yet feature-right CPU-only renderer written in Rust. 

Similarly to Vello CPU, stroking is implemented by reducing the problem to the filling of an equivalent path, but with a small difference: raqote first flattens the stroked path to lines and then generates the stroked path based on the lines. In Vello CPU, it's the other way around, as stroke expansion happens in cubic space and only then is the resulting curve converted to line segments.

An important difference lies in the way normal fills are handled. Unlike Vello CPU, raqote does not flatten curves into line segments but instead uses a rasterizer that can support both line and curve segments. The disadvantage of this approach is that it complicates the rasterization logic as there is  a clear-cut separation of concerns between pipeline stages as in Vello CPU. However, the advantage is that it can handle certain kinds of paths faster, as will be shown in @evaluation.

The main point of distinction between the two renderers is the actual rasterization process. As previously elaborated, Vello CPU generates so-called sparse strips that have a fixed height of 4 and cover possibly anti-aliased parts of the pixmap, while filled areas are only represented implicitly. Vello CPU does _analytical anti-aliasing_, which means that the pixel coverage is calculated by analytically calculating the area of the pixel that is enclosed by the line. The advantage of this technique is that it is relatively fast, but the downside is that it can easily lead to conflation artifacts (as explained in @anti-aliasing), since the method only calculate how much of the area is covered but not actually _which parts_ of the area.

Raqote on the other hand use the classical scan-line rasterization approach, as it is adopted by many other renderers. Conceptually, we iterate from top-to-bottom and consider one row of pixels at a time. At the same time, we store all the edges that are active in that particular pixel row by keeping them in a sorted list that is continuously updated as we step through the pixel rows. For each row, we iterate through the edges in windows of 2 and emit a "span" that ranges from the first edge to the second edge in case the area should be filled according to the winding rule (this is conceptually very similar to how we determine filled areas between two strips in Vello CPU). While doing so, raqote uses _multi-sampled anti-aliasing_: Each pixel is viewed as a 4x4 grid, as can be seen in @msaa-fig. Above we mentioned that the scan-line approach works on a per-row basis, but in reality it actually operates on a _sub-pixel row_ basis, and when processing the edges from the left to the right we determine the sub-pixel columns of that row that should be filled. For a single pixel, we just need to determine how many of the sub-pixel cells are filled to determine the overall opacity of the pixel. The downside of multi-sampled anti-aliasing is that it is usually more expensive, but it can help with guarding against conflation errors, since the approach does not discard information on which _parts_ of the pixel are covered, unlike analytic anti-aliasing.

#figure(image("assets/multi_sampled_aa.svg", width: 50%), caption: [Calculating pixel coverage using 4x4 multi-sampled anti-aliasing. The line touches 6 out of the 16 cells in the sub-pixel grid, so the coverage is $6 / 16 = 37.5%$. It is possible to increase the resolution for example to a 16x16 grid for a higher resolution, but that is performance-wise usually only feasible when using the GPU.], placement: auto) <msaa-fig>

These single spans are then processed in the usual way by computing the color with the paint and then compositing it. Taking this overall design into account, it should become apparent that there is a big weakness in this design: It computes alpha masks for all pixels, even the ones that are strictly on the inside of the shape, while Vello CPU limits this rather expensive computation to the pixels that are within a strip, leaving the sparsely-encoded filled regions "untouched". @evaluation will show that this results in much worse scaling behavior for larger geometries compared to Vello CPU.