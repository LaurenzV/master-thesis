= Comparison <comparison>

In this section, we will briefly contrast the architecture of two different CPU-based 2D renderers against Vello CPU to highlight similarities but also differences. Since there is little literature describing the inner workings of those, we will base most of our descriptions on a best-effort analysis of their source code.

The comparison will demonstrate that certain parts of the 2D rendering pipeline are, with the exception of a few implementation details, virtually universal across different implementations. Yet, the core path-rendering algorithm of Vello CPU, underpinned by the sparse strips paradigm, is a distinguishing feature that separates it from other renderers.

== Raqote
The first renderer is Raqote, a relatively simple yet feature-right CPU-only renderer written in Rust. 

Similarly to Vello CPU, stroking is implemented by reducing the problem to the filling of an equivalent path, but with a small difference: Raqote first flattens the stroked path to lines and then generates the stroked path based on the lines. In Vello CPU, it's the other way around, as stroke expansion happens in cubic space and only then is the resulting curve converted to line segments.

An important difference lies in the way normal fills are handled. Unlike Vello CPU, Raqote does not flatten curves into line segments but instead uses a rasterizer that can support both line and curve segments. The disadvantage of this approach is that it complicates the rasterization logic as there is  a clear-cut separation of concerns between pipeline stages as in Vello CPU. However, the advantage is that it can handle certain kinds of paths faster, as will be shown in @evaluation.

The main point of distinction between the two renderers is the actual rasterization process. As previously elaborated, Vello CPU generates so-called sparse strips that have a fixed height of 4 and cover possibly anti-aliased parts of the pixmap, while filled areas are only represented implicitly. Vello CPU does _analytical anti-aliasing_, which means that the pixel coverage is calculated by analytically calculating the area of the pixel that is enclosed by the line. The advantage of this technique is that it is relatively fast, but the downside is that it can easily lead to conflation artifacts (as explained in @anti-aliasing), since the method only calculate how much of the area is covered but not actually _which parts_ of the area.

Raqote on the other hand use the classical scan-line rasterization approach, as it is adopted by many other renderers. Conceptually, we iterate from top-to-bottom and consider one row of pixels at a time. At the same time, we store all the edges that are active in that particular pixel row by keeping them in a sorted list that is continuously updated as we step through the pixel rows. For each row, we iterate through the edges in windows of 2 and emit a "span" that ranges from the first edge to the second edge in case the area should be filled according to the winding rule (this is conceptually very similar to how we determine filled areas between two strips in Vello CPU). While doing so, Raqote uses _multi-sampled anti-aliasing_: Each pixel is viewed as a 4x4 grid, as can be seen in @msaa-fig. Above we mentioned that the scan-line approach works on a per-row basis, but in reality it actually operates on a _sub-pixel row_ basis, and when processing the edges from the left to the right we determine the sub-pixel columns of that row that should be filled. For a single pixel, we just need to determine how many of the sub-pixel cells are filled to determine the overall opacity of the pixel. The downside of multi-sampled anti-aliasing is that it is usually more expensive, but it can help with guarding against conflation errors, since the approach does not discard information on which _parts_ of the pixel are covered, unlike analytic anti-aliasing.

#figure(image("assets/multi_sampled_aa.svg", width: 50%), caption: [Calculating pixel coverage using 4x4 multi-sampled anti-aliasing. The line touches 6 out of the 16 cells in the sub-pixel grid, so the coverage is $6 / 16 = 37.5%$. It is possible to increase the resolution for example to a 16x16 grid for a higher resolution, but that is performance-wise usually only feasible when using the GPU.], placement: auto) <msaa-fig>

These single spans are then processed in the usual way by computing the color with the paint and then compositing it. Taking this overall design into account, it should become apparent that there is a big weakness in this design: It computes alpha masks for all pixels, even the ones that are strictly on the inside of the shape, while Vello CPU limits this rather expensive computation to the pixels that are within a strip, leaving the sparsely-encoded filled regions "untouched". @evaluation will show that this results in much worse scaling behavior for larger geometries compared to Vello CPU.

Raqote does not make direct use of SIMD instructions and is therefore reliant on the Rust compiler to perform auto-vectorization. It also has no support for multi-threading.

== Blend2D
Blend2D is a C++-based renderer that,
as will become evident in @evaluation, has outstanding performance. On a surface level, Blend2D does many things similarly to other renderers: Before rasterizing, strokes are converted into filled primitives and filled paths are simplified to flattened lines. Like many other renderers, Blend2D fundamentally uses a scan-line rasterizer that processes the pixmap on a per-row level but utilizes a number of clever techniques to ensure faster processing. Similarly to Vello CPU, Blend2D uses an analytical method for fast anti-aliasing calculations.

What makes Blend2D stand out compared to other renderers is not necessarily the used rendering technique, but instead the _way_ those techniques are implemented. A look at the source code reveals that one reason for the exceptional performance of Blend2D is the sheer amount of effort that has been put into optimizations on both the algorithmic level as well as the actual implementation. These range from smaller optimizations like for example using fixed-point math instead of floating-point math when possible to more sophisticated innovations like a customized bit vector storage that allows the compositor to quickly detect and skip empty pixels. Blend2D also makes use of an innovative JIT-compiler to generate highly-efficient SIMD-optimized machine code for parts of the pipeline. In contrast, Vello CPU consists of hand-written kernel functions written in normal Rust. While we tried to ensure that the functions compile to fast code, in the end we are still at the mercy of the compiler to actually generate efficient machine code, while being able to use custom-generated machine code gives you full control over what instructions will actually be executed.

Blend2D is the only other 2D renderer that also supports multi-threading and therefore makes for an interesting comparison. Apart from the fact that the concrete implementation is very different as Blend2D implements custom logic for managing thread pools and scheduling jobs while Vello CPU mostly outsources this to other Rust libraries, there also are crucial differences on a higher level.

Blend2D divides the drawing area into so-called "bands" which can be thought of being similar to wide tiles, but they always span across the whole width instead of having a fixed width of 256 and can also have varying heights. In the first level of parallelism, Blend2D schedules commands for filling and stroking paths to worker threads which will then do stroke expansion and curve flattening in parallel. Then, each worker thread determines which line segments are part of which band and stores that information in a store. Note that this is different to Vello CPU, as in our case in addition to expanding strokes and flattening paths the worker threads will also perform anti-aliasing computations by converting the lines into the sparse strips representation, and then letting the main thread taking care of assigning the commands to wide tiles. 

The second level of parallelism then includes letting each worker thread process a single band and performing rasterization for all lines that were assigned to that band. This is conceptually similar to the second phase of parallelism in Vello CPU when doing fine rasterization, with the main difference being that Blend2D also needs to compute pixel coverages in that phase.

In summary, the overall approach to multi-threading shares similarities, but many details like how work is actually distributed are solved in different ways.