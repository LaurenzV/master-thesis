= Conclusion & Future Work <conclusion>

The main goal of this thesis was to determine whether sparse strips are a suitable approach for implementing a state-of-the-art 2D renderer. To this end, we built a CPU-based 2D renderer with the given paradigm at its core to validate that all of the features expected of a 2D renderer are compatible with the approach#footnote[Other commonly-expected features of a 2D renderer include masks and clip paths, which _are_ supported by Vello CPU but have not been in this work for space reasons]. Our experiments demonstrate that Vello CPU exhibits competitive performance in most cases for small-sized shapes and in particular outperforms nearly all other renderers, including Skia or Cairo, as the shape size increases. An exception is Blend2D, which our renderer cannot beat in the vast majority of cases terms of raw performance output, which we attribute to the large efforts that have been put into optimizing that library. We also show that Vello CPU can achieve even higher speedups by making use of multi-threading, something that many other mainstream renderer cannot make use of due to architectural reasons. It is therefore valid to draw the conclusion that the sparse strips paradigm is very effective and forms a suitable and promising basis for a performant renderer.

Three avenues for future work that could be explored are now presented.


First, it would be interesting to look into how this approach could be adapted for GPU-based rendering. While CPU-based rendering has its use cases, for most interactive rendering workloads it is usually preferable to make use of hardware-acceleration for better throughput. In fact, at the time of writing, there is already an ongoing parallel attempt to create a CPU/GPU-hybrid renderer #footnote[https://github.com/linebender/vello/tree/main/sparse_strips/vello_hybrid (accessed on 11.09.2025)] where the CPU is responsible for all stages up to coarse rasterization and the final fine rasterization happens on the GPU. This current approach already works and highlights the usefulness of having a pipeline consisting of separated stages with well-defined inputs and outputs, but there is a lot more exploration work to be done. A further interesting question would be to determine whether the strip generation stage (in particular, the part of strip generation that is responsible for calculating anti-aliasing) can be moved to the GPU as well, so that all the heavy pixel-level calculations are completely performed on the GPU, while only the more sequential parts of the pipeline (flattening, tile generation and coarse rasterization) are done by the CPU. As part of this, it might also be worthwhile to explore whether a different tile size (for example 8x8) is more suitable for GPU-based rendering compared to the currently-used 4x4 tile size on CPU. While doing so would mean that we need to perform more superfluous anti-aliasing calculations, this is not as much of a problem since the GPU can do those much faster than the CPU. The advantage is that it will reduce the time needed for tile generation and sorting on the CPU, which is likely to form a bottleneck in this GPU-first approach.

Next, the evaluation has shown that Vello CPU has a certain weakness for small geometries. It was also asserted that the most-likely culprit for this behavior is, apart from some algorithmic inefficiencies that should also be addressed, the fixed 4x4 size of tiles, resulting in unnecessary computational work during strip generation. While it is not easily possible to introduce variable-height strips, it _is_ possible to introduce variable-width strips. The way this could be achieved is by letting each tile store the horizontal extents of the containing line and then only computing winding numbers for pixel-columns that are actually covered by a line. A possible downside would be that future steps in the pipeline can no longer assume that the width of a strip is a multiple of four, an assumption that is at the moment baked into most of the SIMD code.

Finally, the third major point that could benefit from more dedicated attention is multi-threading. On the one hand, this includes investigating why the speedup for parallel fine rasterization is not as high as expected. On the other hand, this requires more fundamentally exploring how coarse rasterization, which currently forms the only serial bottleneck in the pipeline, can be made more parallel. There are different approaches that could be explored, like attempting to perform parts of coarse rasterization _within_ the worker, but getting it fully parallelized may not be non-trivial. 
