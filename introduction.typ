= Introduction

2D rendering lies at the heart of virtually all our interactions with digital devices. Whether it be web browsers on our computers, news apps on our phones or ticket machines at the nearest train station: They all rely on 2D rendering to present a user interface that we can interact with.

In most cases, it is preferable to make use of GPUs during the rendering process. GPUs excel at performing thousands of computations at the same, which fits nicely into the 2D rendering paradigm, where the colors for millions of pixels need to be computed as quickly as possible. The relative importance of GPUs in this area is reflected by the fact that the vast majority of research in this direction makes use of them @gpu_accelerated_path_rendering @efficient_gpu_path_rendering_scanline @massively_parallel_vector_graphics.

With that said, utilizing the GPU does come at a cost, and there are situations where it makes more sense to accept the trade-off of slower rendering times by running the rendering pipeline completely on the CPU instead. To name three concrete advantages:

- *Portability*: By relying on the GPU, you are implicitly assuming that the host system actually has a GPU available. While this might be the case for most modern consumer-grade devices, it might not be the case for embedded devices or server appliances. In addition to that, when utilizing the GPU, there are many different competing graphic APIs to choose from, such as Vulkan @vulkan_homepage or OpenGL @opengl_homepage, which come with their own set of trade-offs with regard to platform compatibility. In contrast, by removing any dependence on external GPUs and solely relying on the CPU, it is guaranteed that the program will run on any device as long as a supported target architecture is used.
- *Complexity*: Interfacing into the GPU usually entails a whole lot of additional complexity that is necessary to properly manage the resources and pass data between the GPU and and the host system. For applications with high levels of interactivity, like graphical user interfaces, where having the best performance is absolutely critical, this is often a trade-off worth taking. Still, there are many other situations where maintaining low code complexity and small binary sizes has much higher priority, making fast rendering times only a secondary goal. 
- *Performance*: In comparison to CPU, GPUs undoubtedly have the upper hand when it comes to processing millions of pixels at the same time. Yet, GPUs do also have performance cliffs. For example, there can be a significant latency on startup as the GPU context needs to be initialized and setup. This latency might not be a problem for GUI applications where a one-time startup latency is barely noticeable, but it could be problematic if all we want to do is a one-time rendering operation of a single image.

Doing 2D rendering on the CPU is in some sense an already solved problem, as there already exists a plethora of libraries that can do the job, including for example Skia @skia or Cairo @cairo. which have both been existing for more than a decade. However, the question of which _fundamental rendering technique_ is the best from the standpoint of performance and efficiency is very much an open research question. This is especially true as the capabilities of our CPUs have been constantly evolving, with the addition of features like SIMD and multi-threading offering new opportunities for exploring and researching different rendering paradigms. This is evidenced by the recent emergence of Blend2D @blend2d, a CPU-renderer that for the first time offers multi-threading capabilities and beats all existing renderers by a wide margin in many benchmarks @blend2d_perf thanks to a novel rendering architecture based on just-in-time compilation.

The main motivation for this thesis is two-fold. On the one hand, we wish to fill an important gap in literature, as 2D rendering is a subfield of computer graphics that has generally received little academic interest. Our hope is that this work can serve as a solid introduction into this field by explaining foundational knowledge in an approachable way and providing detailed explanations of the inner workings of a feature-complete and performant CPU-based 2D renderer.

On the other hand, we want to make a contribution to the research question of finding the "best" rendering technique by exploring a novel rendering paradigm that is based on so-called _sparse strips_, a new sparsely encoded representation of rendered vector paths. This paradigm borrows some key ideas from the concept of so-called _merged boundary fragments_ as they are presented in #cite(<efficient_gpu_path_rendering_scanline>, form: "prose"), but extends the idea in a number of ways to make it more amenable to SIMD optimizations and multi-threading. In order to validate the idea, we build a completely new CPU-based renderer from scratch called _Vello CPU_ @vello_cpu. It is fully based on the sparse strips idea and supports most features that are usually expected from a 2D renderer. The implementation will be done using the Rust programming language @rust.

The remainder of this thesis is structured as follows: In @background, some of the basic concepts of 2D rendering will be explained, as they are prerequisites for the following chapters. In @architecture, a holistic overview of the whole architecture of Vello CPU will be given by providing detailed explanations on the functionality of each part of the rendering pipeline. Two extra subsections will be dedicated to describing how the pipeline is SIMD-optimized and compatible with multi-threading. In @comparison, we will compare the design of Vello CPU against two other renderers two highlight similarities but also the novelty of our renderer.  In @evaluation, the performance of Vello CPU will be comprehensively evaluated by running it against the Blend2D benchmark suite @blend2d_perf and comparing performance against other renderers. Finally, in @conclusion, the main findings will be summarized and suggestions for potential future work will be given.

