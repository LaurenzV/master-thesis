= Introduction

2D rendering lies at the heart of virtually all our interactions with digital devices. Whether it be web browsers on our computers, news apps on our phones or ticket machines at the nearest train station: They all rely on 2D rendering to present a user interface that we can interact with.

In most cases, it is preferable to make use of GPUs during the rendering process. GPUs excel at performing thousands of computations at the same, which fits nicely into the 2D rendering paradigm where the colors for millions of pixels need to be computed as quickly as possible. The importance of GPUs in this area is reflected by the fact that the vast majority of research in this direction makes use of them @gpu_accelerated_path_rendering @efficient_gpu_path_rendering_scanline @massively_parallel_vector_graphics.

With that said, utilizing the GPU does come at a cost, and there are situations where it makes more sense to accept the trade-off of (often) slower rendering times by running the rendering pipeline on the CPU instead. To name three concrete advantages of doing so:

- *Portability*: By relying on the GPU, you are implicitly assuming that the host system actually has a GPU available. While this might be the case for most modern consumer-grade devices, it might not be the case for embedded devices or server appliances. In addition to that, when utilizing the GPU, there are many different competing graphic APIs to choose from, such as Vulkan #footnote[https://www.vulkan.org (accessed on 15.09.2025)] or OpenGL #footnote[https://www.opengl.org (accessed on 15.09.2025)], which come with their own set of trade-offs with regard to platform compatibility. In contrast, by removing any dependence on external GPUs and solely relying on the CPU, it is guaranteed that the program will run on any kind of device as long as a supported target architecture is used.
- *Complexity*: Interfacing into the GPU usually entails a whole lot of additional complexity that is necessary to properly manage the resources and pass data between the GPU and the host system. For applications with high levels of interactivity, like graphical user interfaces, where having the best performance is absolutely critical, this is often a trade-off worth taking. Still, there are many other situations where maintaining low code complexity and small binary sizes has higher priority, making the simplicity of CPUs more attractive. 
- *Performance*: In comparison to CPUs, GPUs undoubtedly have the upper hand when it comes to processing millions of pixels at the same time. Yet, GPUs do also have performance cliffs. For example, there can be a significant latency on startup as the GPU context needs to be initialized and set up. This latency might not be a problem for GUI applications where a one-time startup latency is barely noticeable, but it could become very cumbersome in situations where we only want to run a one-time rendering operation, for example when rendering to an image.

Doing 2D rendering on the CPU is in some sense an already solved problem, as there already exists a plethora of libraries that can do the job, including for example Skia #footnote[https://skia.org (accessed on 15.09.2025)] or Cairo #footnote[https://www.cairographics.org (accessed on 15.09.2025)], which have both been existing for more than a decade. However, the question of which _fundamental_ approach to rendering is the best from the standpoint of performance and efficiency is an open research question. This is especially true as the capabilities of our CPUs have been constantly evolving, with the addition of features like SIMD and multi-threading offering new opportunities for exploring and researching different rendering paradigms. This is evidenced by the recent emergence of Blend2D #footnote[https://blend2d.com (accessed on 15.09.2025)], a CPU-renderer that for the first time offers multi-threading capabilities and beats all existing renderers by a wide margin in many benchmarks according to @blend2d_perf, in part thanks to a novel rendering architecture based on just-in-time compilation.

The main motivation for this thesis is two-fold. On the one hand, we wish to fill an important gap in literature, as 2D rendering is a subfield of computer graphics that has generally received little academic interest in recent years. Our hope is that this work can serve as an introduction into this field by explaining relevant foundational knowledge in an approachable way by explaining the inner workings of a feature-complete and performant CPU-based 2D renderer in an approachable manner.

On the other hand, we want to make a contribution to the research question of finding the "best" rendering technique by exploring a novel rendering paradigm that is based on so-called _sparse strips_, a new sparsely encoded representation of rendered vector paths. This paradigm borrows some key ideas from the concept of so-called _merged boundary fragments_ as they are presented by #cite(<efficient_gpu_path_rendering_scanline>, form: "prose"), but extends the idea in a number of ways to make it more amenable to SIMD optimizations and multi-threading. In order to validate the idea, we build a new CPU-based renderer from scratch called _Vello CPU_ #footnote[https://github.com/linebender/vello/tree/main/sparse_strips/vello_cpu (accessed on 15.09.2025)] in this master's thesis. It is fully based on the sparse strips idea and supports most features that are usually expected from a 2D renderer. The implementation will be done using the Rust programming language.

The remainder of this thesis is structured as follows: In @background, some of the basic concepts of 2D rendering will be explained, as they are prerequisites for the following chapters. In @architecture, a holistic overview of the whole architecture of Vello CPU will be given by providing detailed explanations on the functionality of each part of the rendering pipeline. Two additional subsections will be dedicated to describing how the pipeline is SIMD-optimized and compatible with multi-threading. In @comparison, we will contrast the design of Vello CPU against two other renderers to highlight similarities but also emphasize the novelties of our architecture.  In @evaluation, the performance of Vello CPU will be comprehensively evaluated by running it against the Blend2D benchmark suite @blend2d_perf and comparing the performance against many other available 2D renderers. Finally, in @conclusion, the main findings will be summarized and suggestions for potential future work will be given.

